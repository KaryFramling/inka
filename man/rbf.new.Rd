% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RBF.R
\name{rbf.new}
\alias{rbf.new}
\title{Create new RBF network object.}
\usage{
rbf.new(
  nbrInputs,
  nbrOutputs,
  n.hidden.neurons,
  activation.function = squared.distance.activation,
  output.function = imqe.output.function,
  normalize = TRUE,
  spread = 0.1
)
}
\arguments{
\item{nbrInputs}{blabla}

\item{nbrOutputs}{blabla}

\item{n.hidden.neurons}{blabla}

\item{activation.function}{blabla}

\item{output.function}{blabla}

\item{normalize}{blabla}

\item{spread}{blabla}
}
\value{
New RBF network (class RBF, inherits FunctionApproximator),
with following properties:
\itemize{
\item nbrInputs: Number of inputs
\item nbrOutputs: Number of outputs
\item n.hidden.neurons: Number of hidden neurons (allowed to provide zero as value)
\item activation.function: The activation function to be used by hidden layer neurons
\item output.function: Output function to use for hidden layer neurons
\item normalize: Normalize hidden layer outputs or not, i.e. "ordinary" RBF or normalized RBF
}
}
\description{
Create new RBF network object.
}
\examples{
# Create RBF network manually, one input, one output. "Normalised" RBF (default)
# First empty hidden layer, then configure weights manually.
rbf <- rbf.new(1, 1, 0)
ol <- rbf$get.outlayer()
ol$set.weights(matrix(c(1,2),nrow=1,ncol=2))
hl <- rbf$get.hidden()
hl$set.weights(matrix(c(1,5),nrow=2,ncol=1,byrow=TRUE))

# See what it looks like. Centroids at x=1 and x=5. Slight overshooting
# in y-values, which is normal (no training yet).
x <- matrix(seq(-5,10,0.1))
y <- rbf$eval(x)
plot(x, y, type='l')

# Example of matrix inversion "learning" on output layer weights.
# Create small training set and train with QR-decomposition
x <- matrix(c(0,0,1,1,1,0,0,1), ncol=2, byrow=TRUE)
y <- matrix(c(0,1,0.3,0.6),ncol=1)
n.hidden <- 4
rbf <- rbf.new(2, 1, n.hidden)
hl <- rbf.classifier.new(nbrInputs=2, nbrOutputs=n.hidden)
rbf$set.hidden(hl)
mins <- c(0,0); maxs <- c(1,1)
xints <- yints <- 2
hl$init.centroids.grid(mins, maxs, c(xints,yints))
rbf$set.spread(0.5)
outp <- rbf$eval(x)
h.out <- hl$get.outputs()
w <- qr.solve(h.out, y)
ol <- rbf$get.outlayer()
ol$set.weights(t(w))

# See if the examples were learned correctly.
rbf$eval(x)

# Plot function in 3D
xp <- yp <- seq(0,1,0.05)
m <- expand.grid(xp,yp)
z <- rbf$eval(m)
zm <- matrix(data=z, nrow=length(xp), ncol=length(yp), byrow=TRUE)
persp(xp, yp, zm, zlim=c(-0.1,1.1), theta=15, phi=20, shade=0.3, ticktype="detailed")
}
