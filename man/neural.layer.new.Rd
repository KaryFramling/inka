% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NeuralLayer.R
\name{neural.layer.new}
\alias{neural.layer.new}
\title{Neural layer object implementation.}
\usage{
neural.layer.new(
  nbrInputs,
  nbrOutputs,
  activation.function,
  output.function,
  use.trace = FALSE,
  use.bias = FALSE
)
}
\arguments{
\item{nbrInputs}{blabla}

\item{nbrOutputs}{blabla}

\item{activation.function}{blabla}

\item{output.function}{blabla}

\item{use.trace}{blabla}

\item{use.bias}{blabla}
}
\value{
Object of class NeuralLayer (which also inherits FunctionApproximator)
}
\description{
Neural layer object implementation.
}
\examples{
# Create simple weighted sum layer (one neuron) with fixed neurons and
# call "eval" for input values (1,1).
l <- neural.layer.new(2, 1, weighted.sum.activation, identity.output.function)
l$set.weights(matrix(c(1, 2), nrow=1, ncol=2))
l$eval(c(1,1))

# Plot what it looks like (needs "graphics")
x <- y <-seq(0,1,0.05)
m <- expand.grid(x,y)
persp(x, y, matrix(l$eval(m), nrow=length(x)), ticktype="detailed")

# Test squared distance. One input, two "kernels".
l <- neural.layer.new(1, 2, squared.distance.activation, imqe.output.function)
l$set.weights(matrix(c(1, 2), nrow=2, ncol=1, byrow=TRUE))
l$set.spread(1.0)
l$eval(c(2))
x <- matrix(seq(0,3,0.1), ncol=1)
plot(x, l$eval(x)[,1], type="l")
lines(x, l$eval(x)[,2], col="blue")

# Study output function shapes a little
# IMQE versus Gaussian
s<-seq(0,100,0.1)
plot(s,imqe.output.function(s),type='l', col='black', ylim=c(0,1))
lines(s,gaussian.output.function(s),col='green')

# Sigmoid
s<-seq(-5,5,0.1)
plot(s,sigmoid.output.function(s),type='l', col='black', ylim=c(0,1))
}
